;;-----------------------------LICENSE NOTICE------------------------------------
;;  This file is part of CPCtelera: An Amstrad CPC Game Engine
;;  Copyright (C) 2021 ronaldo / Fremos / Cheesetea / ByteRealms (@FranGallegoBR)
;;  Copyright (C) 2021 Nestornillo (https://github.com/nestornillo)
;;
;;  This program is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU Lesser General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;
;;  This program is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU Lesser General Public License for more details.
;;
;;  You should have received a copy of the GNU Lesser General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;-------------------------------------------------------------------------------


;;//////////////////////////////////////////////////////////////////////
;;//////////////////////////////////////////////////////////////////////
;; File: Macros (asm)
;;//////////////////////////////////////////////////////////////////////
;;//////////////////////////////////////////////////////////////////////

;;//////////////////////////////////////////////////////////////////////
;; Group: Firmware Macros
;;//////////////////////////////////////////////////////////////////////

;;
;; Macro: cpctm_createInterruptHandlerWrapper_asm
;;
;;    Macro that creates a custom interrupt handler wrapper function.
;;
;; ASM Definition:
;; .macro <cpctm_createInterruptHandlerWrapper_asm> *WRAPPERNAME*, *INTHANDLER*,
;; *R1*, *R2*, *R3*, *R4*, *R5*, *R6*, *R7*, *R8*, *R9*, *R10*, *R11*
;;
;; Parameters:
;; WRAPPERNAME - Name of the generated wrapper function.
;; INTHANDLER - A pointer to the interrupt handler function that will be wrapped
;; R1-R11 - List of registers to be saved (*af*, *bc*, *de*, *hl*, *ix*, *iy*,
;; or *alt* for choosing alternate registers)
;;
;; Details:
;;   This macro generates a wrapper function to safely call user provided
;; *intHandler*. This code saves on the stack the registers that are specified
;; in the parameters of the macro. The selected registers are restored after
;; user code from *intHandler* finishes. Therefore, user does not have to worry
;; about saving and restoring registers during interrupts. However, when using
;; this macro, user is responsible for choosing which registers are saved. Be
;; aware that in most cases all standard registers (AF BC DE HL IX IY) should be
;; preserved.
;;
;;   First parameter of the macro calling is the name that will be assigned to
;; the resulting wrapper function.
;;
;;   Second parameter is a pointer to the interrupt handler function that will
;; be wrapped with the code generated by this macro.
;;
;;   Next optional parameters are the registers that will be preserved in the
;; resulting code. We can use symbols *af*, *bc*, *de*, *hl*, *ix* and *iy* to
;; indicate which standard registers should be saved. After standard registers
;; we can use symbol *alt* to indicate that following parameters refer to
;; alternate registers, which can be specified with symbols *af*, *bc*, *de*,
;; and *hl*.
;;
;;   As opposed to <cpct_setInterruptHandler>, the code generated by this macro
;; does not modify the interrupt vector to establish the resulting function as a
;; new interrupt handler. That can be done using <cpct_setInterruptHandler_naked>.
;;
;; Examples of use:
;;   For next examples we'll suppose that *myIntHandler* is an interrupt handler
;; function defined by the user.
;; * Saving standard registers
;; (start code)
;; cpctm_createInterruptHandlerWrapper_asm StandardRegsWrapper, myIntHandler, af, bc, de, hl, ix, iy
;; (end code)
;; Previous line will create a function named *StandardRegsWrapper*. This function
;; will save standard registers (AF, BC, DE, HL, IX, IY) before calling the
;; interrupt handler function *intHandler*. When *intHandler* returns,
;; *StandardRegsWrapper* will restore the saved registers before exiting the interrupt.
;; In order to use the generated routine, we can use <cpct_setInterruptHandler_naked>
;; to patch the interrupt vector.
;; (start code)
;; ld hl,#StandardRegsWrapper
;; call cpct_setInterruptHandler_naked_asm
;; (end code)
;; If we want to use our assembler generated function in a C file, first we'll
;; need to declare it using <cpctm_declareInterruptHandlerWrapper> macro, as shown
;; in next example.
;; (start code)
;; cpctm_declareInterruptHandlerWrapper(StandardRegsWrapper);
;; // ...
;; void init(void) {
;;  // ...
;;  cpct_setInterruptHandler_naked(StandardRegsWrapper);
;; }
;; (end code)
;; * Saving all registers
;;
;;   Next line will create *AllRegsWrapper* function. This created function will
;; preserve all standard and alternate registers in the interrupt handler calling.
;; (start code)
;; cpctm_createInterruptHandlerWrapper_asm AllRegsWrapper, myIntHandler, af, bc, de, hl, ix, iy, alt, af, bc, de, hl
;; (end code)
;; * Saving no registers
;;
;;   If you don't need to preserve any register you can use the next calling. Be
;; aware that in most cases you will need to preserve at least the standard registers.
;; (start code)
;; cpctm_createInterruptHandlerWrapper_asm NoRegsWrapper, myIntHandler
;; (end code)
;; * Saving standard registers + AF' + HL'
;;
;;   As another example, next line creates a custom interrupt handler wrapper that
;; preserves standard registers (AF BC DE HL IX IY) and also preserves AF' and HL'.
;; (start code)
;; cpctm_createInterruptHandlerWrapper_asm MyWrapper, myIntHandler, af, bc, de, hl, ix, iy, alt, af, hl
;; (end code)
;;
;; Known issues:
;;   * This macro can only be used from assembler code. It is not accessible from
;; C scope. For C programs, please refer to <cpctm_createInterruptHandlerWrapper>
;; C macro. However, the resulting code of this macro can be used from a C scope.
;;   * This macro will work *only* with constant values, as its value needs to
;; be calculated in compilation time. If fed with variable values, it will give
;; an assembler error.
;;
;; Size of generated code:
;;    Depending on which registers you choose to preserve the resulting code will
;; vary its size. Next are some values as a reference.
;; (start code)
;; Case                     | Size
;; ------------------------------------
;; No registers saved       |  6 bytes
;; Standard registers saved | 22 bytes
;; All registers saved      | 34 bytes
;; ------------------------------------
;; (end code)
;;
;; Time Measures:
;;  * This measure is the time overhead required for safely calling user defined
;; function. That is, time required by the generated wrapper function to save
;; registers, call user's *intHandler*, restoring the registers and returning.
;; This overhead is to be assumed each time interrupt handler is called, so up
;; to 6 times per frame, 300 times per second. Depending on which registers you
;; choose to be saved, the resulting function will take different time to
;; complete. Next measures show some possible cases.
;; (start code)
;; Case                     | microSecs (us) | CPU Cycles
;; -------------------------------------------------------
;; No registers saved       |      10        |     40
;; Standard registers saved |      56        |    224
;; All registers saved      |      88        |    352
;; -------------------------------------------------------
;; (end code)
;;

.mdelete cpct_checkReg_
.macro cpct_checkReg_
.endm

.mdelete cpct_checkReg_alt
.macro cpct_checkReg_alt
  .equ cpct_altDetected, 1
.endm

.mdelete cpct_checkReg_af
.macro cpct_checkReg_af
  .if cpct_altDetected
    .equ cpct_altAFdetected, 1
  .endif
.endm

.mdelete cpct_checkReg_bc
.macro cpct_checkReg_bc
  .if cpct_altDetected
    .equ cpct_altBCDEHLdetected, 1
  .endif
.endm

.mdelete cpct_checkReg_de
.macro cpct_checkReg_de
  .if cpct_altDetected
    .equ cpct_altBCDEHLdetected, 1
  .endif
.endm

.mdelete cpct_checkReg_hl
.macro cpct_checkReg_hl
  .if cpct_altDetected
    .equ cpct_altBCDEHLdetected, 1
  .endif
.endm

.mdelete cpct_checkReg_ix
.macro cpct_checkReg_ix
.endm

.mdelete cpct_checkReg_iy
.macro cpct_checkReg_iy
.endm

.mdelete cpct_saveReg_
.macro cpct_saveReg_
.endm

.mdelete cpct_saveReg_alt
.macro cpct_saveReg_alt
  .if cpct_altAFdetected
    ex af, af' ;; [1]
  .endif
  .if cpct_altBCDEHLdetected
    exx        ;; [1]
  .endif
.endm

.mdelete cpct_saveReg_af
.macro cpct_saveReg_af
  push af    ;; [4]
.endm

.mdelete cpct_saveReg_bc
.macro cpct_saveReg_bc
  push bc    ;; [4]
.endm

.mdelete cpct_saveReg_de
.macro cpct_saveReg_de
  push de    ;; [4]
.endm

.mdelete cpct_saveReg_hl
.macro cpct_saveReg_hl
  push hl    ;; [4]
.endm

.mdelete cpct_saveReg_ix
.macro cpct_saveReg_ix
  push ix    ;; [5]
.endm

.mdelete cpct_saveReg_iy
.macro cpct_saveReg_iy
  push iy    ;; [5]
.endm

.mdelete cpct_restoreReg_
.macro cpct_restoreReg_
.endm

.mdelete cpct_restoreReg_alt
.macro cpct_restoreReg_alt
  .if cpct_altBCDEHLdetected
    exx        ;; [1]
  .endif
  .if cpct_altAFdetected
    ex af, af' ;; [1]
  .endif
.endm

.mdelete cpct_restoreReg_af
.macro cpct_restoreReg_af
  pop af     ;; [3]
.endm

.mdelete cpct_restoreReg_bc
.macro cpct_restoreReg_bc
  pop bc     ;; [3]
.endm

.mdelete cpct_restoreReg_de
.macro cpct_restoreReg_de
  pop de     ;; [3]
.endm

.mdelete cpct_restoreReg_hl
.macro cpct_restoreReg_hl
  pop hl    ;; [3]
.endm

.mdelete cpct_restoreReg_ix
.macro cpct_restoreReg_ix
  pop ix    ;; [4]
.endm

.mdelete cpct_restoreReg_iy
.macro cpct_restoreReg_iy
  pop iy    ;; [4]
.endm

.macro cpctm_createInterruptHandlerWrapper_asm WrapperName, intHandAddress, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11
  .equ cpct_altAFdetected, 0
  .equ cpct_altBCDEHLdetected, 0
  .equ cpct_altDetected, 0
  cpct_checkReg_'R1
  cpct_checkReg_'R2
  cpct_checkReg_'R3
  cpct_checkReg_'R4
  cpct_checkReg_'R5
  cpct_checkReg_'R6
  cpct_checkReg_'R7
  cpct_checkReg_'R8
  cpct_checkReg_'R9
  cpct_checkReg_'R10
  cpct_checkReg_'R11
  WrapperName::
  _'WrapperName::
  cpct_saveReg_'R1
  cpct_saveReg_'R2
  cpct_saveReg_'R3
  cpct_saveReg_'R4
  cpct_saveReg_'R5
  cpct_saveReg_'R6
  cpct_saveReg_'R7
  cpct_saveReg_'R8
  cpct_saveReg_'R9
  cpct_saveReg_'R10
  cpct_saveReg_'R11

  call #intHandAddress ;; [5] Call Interrupt Handler

  cpct_restoreReg_'R11
  cpct_restoreReg_'R10
  cpct_restoreReg_'R9
  cpct_restoreReg_'R8
  cpct_restoreReg_'R7
  cpct_restoreReg_'R6
  cpct_restoreReg_'R5
  cpct_restoreReg_'R4
  cpct_restoreReg_'R3
  cpct_restoreReg_'R2
  cpct_restoreReg_'R1
  ei       ;; [1] Reenable interrupts
  reti     ;; [4] Return to main program
.endm
